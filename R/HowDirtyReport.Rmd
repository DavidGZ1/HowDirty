---
title: Evaluation of LC-MS contamination risk (HowDirty)
output:
  html_document:
    toc: true
    toc_float: false
    theme: united
    number_sections: TRUE
runtime: shiny
params:
  DataSet: 
    label: "Data set or experiment (keep it short since it's used as prefix for output file names)"
    value: 2022-132_FASP_filters
    input: text
  UserNames: 
    label: "User(s)"
    value: 
    input: text
  Notes:
    label:
    value:
    input: text
  PeakAreasContaminantsFile:
    label: "PeakAreaContaminants report from Skyline"
    value: data/PeakAreas_Contaminants_2023-231.csv # PeaKAreas_Contaminants report (directory/name) resulting from Skyline
  AnnotationFile:
    label: "Sample annotation file"
    value: data/samples_annotation_20223-231.csv # Samples Annotation directory/name
  RefThresholdsFile:
    label: "Reference threshold file (total)"
    value: data/contaminants_tshd_2021_E480.csv # A file directory/name in or FALSE if no threshold available
  RefThresholdsSampleLevelFile:
    label: "Reference threshold file (sample)"
    value: data/contaminants_tshd_sample_2021_E480.csv # A file directory/name or FALSE if no threshold available
  OutputDirectory:
    label: "Directory where the report and the results are exported"
    value: results
  nTopContaminants:
    label: 
    value: 5
    input: numeric
  MultiplyDilutionFactor:
    label:
    value: FALSE #Use carefully, normalization by TIC already takes into account slight differences in injection amounts
  PlotsInteractive: 
    label:
    value: TRUE #TRUE = interactive in html, FALSE = static
  PlotsSave:
    label:
    value: FALSE #Saves all the plots as .jpg
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Report information

## Data set information

**Data set:** `r params$DataSet`

**User(s):** `r params$UserNames`

**Date:**  `r Sys.Date()` 

**Notes:** `r params$Notes`

**Objective:** Evaluate the risk of possible contamination with polymers and small molecules in the samples from the data set.

## HowDirty evaluation of LC-MS results

This report was generated with a prototype version of *HowDirty*. This is meant to help you evaluating *How Dirty* are your samples (or system) in LC-MS analyses. The possible contaminants reported hereby could impact the quality of the results (e.g. analyte IDs and reproducibility) and, in extreme cases, even damage the column or instruments. The raw data are previously analyzed using Skyline to extract LC-MS peaks possibly corresponding to contaminants. Then, a Risk level is assigned to each contaminant by comparing against the reference threshold (see Procedures for details). Finally, the Risk is similarly assessed at the Sample and whole Sample Set levels. These are indicative of the level of possible contamination.

**Code author:** David Gomez-Zepeda (HI-TRON)

**Version:** 0.04

```{r global_options, include=FALSE, echo=FALSE}
#General parameters for knitr
require("knitr")
# knitr::opts_knit$set(root.dir = '/tmp')
opts_knit$set(root.dir = normalizePath("..")) #Set wd to folder above
opts_chunk$set(echo = FALSE, message = TRUE, warning = FALSE)
```

```{r verify_files, include=FALSE, echo=FALSE}
# verify that parameters were filled
if(is.null(params$PeakAreasContaminantsFile))  stop("Please enter the PeakAreasContaminantsFile")
if(is.null(params$RefThresholdsFile)) stop("Please enter the RefThresholdsFile")
if(is.null(params$ RefThresholdsSampleLevelFile)) stop("Please enter the RefThresholdsSampleLevelFile")
# verify that files exist
filenames <- unlist(params[grepl("File" , names(params))])
filenames <- filenames[filenames != "FALSE"] # ignore if FALSE (e.g. for thresholds)
filecheck <- file.exists(filenames) 
if(any(!filecheck)){
  files_missing <- filenames[!filecheck] %>% 
    data.frame(File=names(.), Entry=., row.names=NULL) %>% 
    mutate(message = paste0(File, ": ", Entry,"\n"))
  stop("The input files below were not found. Please verify that they are in the right location: \n ", files_missing$message)
}
```

```{r initialize, message=FALSE, include=FALSE}
#Install required packages
##Test whether all required packages, install packages needed and install if needed
required_packages <- c('ggplot2', 'ggpubr', 'scales', 'plotly',
              'openxlsx', 'mgsub', 'DT', 'shiny', 'tidyverse', 'HowDirty')
# required_packages <- c(packages)
installed_packages <- required_packages %in% installed.packages()[,"Package"]
missing_packages <- required_packages[!installed_packages]
if ( length(missing_packages) > 0 ) install.packages(packages)
##Load libraries
invisible(lapply(required_packages, require, character.only = TRUE))
# names for output files
today_date <- gsub(patt ="-", rep="",paste0(gsub(patt ="-", rep="", Sys.Date()), "_", format(Sys.time(), "%H%M")))
filedir_report <- file.path(params$OutputDirectory,
                            paste0(params$DataSet, "_report_contaminants_", today_date, ".xlsx"))
filedir_sessioninfo <- gsub(filedir_report, patt = ".xlsx", rep = "_RSessionInfo.txt", filedir_report)
```

```{r functions2move}
count_factor_columns <- function(df){
  df  %>% 
    summarise(across(where(is.factor), ~n_distinct(.x))) %>% 
    t() %>% 
    as.data.frame() %>% 
    rename("Count" = 1) %>% 
    rownames_to_column("Variable")
}
scale_fill_risk_level <- function(..., option = "plasma", direction = 1){
  # options = "RdOrBlu", "plasma"
  if(option ==  "RdOrBlu"){colors_risk = c('#d73027','#f46d43','#fdae61', '#fee090','#abd9e9','#74add1','#4575b4')} #https://colorbrewer2.org/#type=diverging&scheme=RdYlBu&n=8
  if(option ==  "plasma"){colors_risk = c("#0D0887FF", "#5002A2FF", "#8405A7FF", "#B12A90FF",  "#D35171FF", "#ED7953FF", "#FCA636FF")}  #c(scales::viridis_pal(end=0.8, option =  "plasma", direction = 1)(7))
  if(!option %in% c("RdOrBlu", "plasma")) stop("option must be = c(RdYlBlu, plasma)")
  if(direction == 1){colors_risk = colors_risk}
  if(direction == 1){colors_risk = rev(colors_risk)}
  if(!direction %in% c(-1,1))stop("risk must be = c(0,1)")

  ggplot2:::manual_scale(
    'fill',
    values = setNames(colors_risk,
                      c("1) Very Low (OK)", "2) Low (OK)", "3) Medium (Warning)", "4) High (Warning)", "5) Very High (DO NOT PROCEED)", "6) No theshold in reference")),
    ...
  )
}
```

```{r functions_in_progress}

```

```{r rawr_ggsave}
# Other functions
# rawr_ggsave <-function(input, file, width = 20, height = 24) {
#   ggsave(file.path("4_figures", paste0(file, ".tiff")) , input, device =  "tiff", 
#          scale = 1, width = width, height = height, units = "cm")
# }
```

# Procedure

## Data analysis

* Raw data was imported into Skyline to extract the features corresponding to possible contaminants (ToDo: add references)
* For this purpose,the Molecular Contaminant List template was used (Gomez-Zepeda *et al.*, 2023; modified from Rardin, 2018)
* The feature area of extracted ion chromatograms was processed using *HowDirty* to generate this report (Gomez-Zepeda *et al.*, 2023)

## Warning

The algorithm used for peak picking in Skyline is simple and based only in m/z and charge (z). Thus, some true analyte peaks (e.g. peptides) could be incorrectly assigned to contaminants (i.e. false positives). Therefore, it is recommended to also look into the Skyline file to evaluate other factors, such as patterns of contaminant groups elution across the retention time.

## Calculations within *HowDirty*

* TICA = Total Ion Current Area
* Abundance (Normalized abundance) = TotalAreaMS1 / TICA
* TotalAbundance_ContaminantGroup = Sum (Abundance_ContaminantGroup) across all the contaminants in one ContaminantGroup for one sample.
* TotalAbundance = Sum (Abundance) across all the contaminants for one sample
* Contaminant-specific Risk level assessment was performed by comparing the Abundance of the possible contaminants in each one of the test samples (current data set) against thresholds previously extrapolated from a reference data set (~ 1000s runs). These thresholds are reported in `r filedir_report`--> ref_conta_tshd.
* Sample level summary contaminant group assessment was performed by comparing the TotalAbundance_ContaminantGroup against the summed thresholds from each contaminant.
* Sample level summary contaminant risk assessment was performed by comparing the TotalAbundance against the sample-level quantile thresholds from the reference dataset. These thresholds are reported in `r filedir_report`--> ref_conta_tshd_sample.

# Input

```{r read_data}
# Load thresholds
if(params$RefThresholdsFile == FALSE){
  # set arbitrary thresholds
  ref_conta_tshd <- get_simple_thresholds_analyte(conta_raw)
  ref_conta_tshd_sample <- get_simple_thresholds_sample()
  message("WARNING: Reference Threshold File was not provided. Thus, threshold were set at the same level for all the contaminants")
} else{ 
  # read thresholds from file
  ref_conta_tshd <- read.csv(params$RefThresholdsFile) %>% 
    select(-any_of("X"))
  ref_conta_tshd_sample <- read.csv(params$RefThresholdsSampleLevelFile) %>% 
    select(-any_of("X"))
}
# read files
## Skyline results of contaminant peak area and height
conta_raw <- read_conta_results(file_report_skyline = params$PeakAreasContaminantsFile)
## information about samples (annotation)
samples_annot <- read_samples_annotation(params$AnnotationFile) 
## check if all samples are included in both results and annotation file
check_samples_in_results(conta_raw, samples_annot)
```

```{r annotate_results}
# Annotate contamination results with samples_annot, multiply by dilution_factor, assign risk level
conta <- conta_raw %>% 
  annotate_conta_samples(., samples_annot, # Annotate with samples_annot, multiply by dilution_factor
                         multiply_dilution_factor = params$MultiplyDilutionFactor) %>% 
  annotate_conta_thresholds(., ref_conta_tshd) # assign RiskLevel
```

The data set contained the following:

```{r summary_input}
count_factor_columns(conta) %>% 
  filter(!Variable %in% c("Risk", "RiskLevel")) %>% 
  mutate(Variable = paste0(Variable, "s")) %>% 
  kable() 
```

```{r summaries}
#Summary of thresholds for each contaminant group
ref_conta_tshd_sum <-  ref_conta_tshd %>% 
  group_by(AnalyteGroup) %>% 
  summarise(across(starts_with("Tshd"), sum), .groups = "drop")

## Summary by Analyte Group, needed to get top groups
conta_summ_analytegroup <-
  conta %>%
  group_by(AnalyteGroup) %>% 
  summarise(across(c(Abundance),
                   list(min = ~min(.x, na.rm = TRUE),
                        quantile25 = ~quantile(.x, na.rm = TRUE)[2],
                        median = ~median(.x, na.rm = TRUE),
                        quantile75 = ~quantile(.x, na.rm = TRUE)[4],
                        max = ~max(.x, na.rm = TRUE))),
            .groups = "drop") %>% 
  mutate(across(where(is.numeric), ~signif(.x, 4)))

conta_summ_analyte <-
  conta %>%
  group_by(AnalyteGroup, Analyte) %>% 
  summarise(across(c(Abundance),
                   list(min = ~min(.x, na.rm = TRUE),
                        quantile25 = ~quantile(.x, na.rm = TRUE)[2],
                        median = ~median(.x, na.rm = TRUE),
                        quantile75 = ~quantile(.x, na.rm = TRUE)[4],
                        max = ~max(.x, na.rm = TRUE))),
            .groups = "drop")  %>% 
  mutate(across(where(is.numeric), ~signif(.x, 4)))

## top contaminants
analytegroups_area_ordered <- 
  conta_summ_analytegroup %>% 
  select(AnalyteGroup, Abundance_median) %>% 
  unique() %>% 
  arrange(desc(Abundance_median))

## Sample level
conta_summ_sample <-
  conta %>%
  group_by(Condition, Sample, ReplicateName) %>%
  summarise(TotalAbundance = round(sum(Abundance, na.rm=TRUE), 4), .groups = "drop") %>%
  mutate(Risk =
           cut(x = TotalAbundance,
               breaks = ref_conta_tshd_sample$Break,
               labels = ref_conta_tshd_sample$Labels[-1]))  %>%
  drop_na %>%
  mutate(RiskLevel= as.numeric(substr(as.character(Risk),1,1)),
         RiskLevel = factor(RiskLevel, levels = c(0:6))) %>%
  relocate(Condition, Sample, ReplicateName, TotalAbundance, RiskLevel, Risk) %>%
  # Join with median from top 8 contaminants
  full_join(.,
            conta %>%
              # filter(AnalyteGroup %in% top_analytegroups_area$AnalyteGroup) %>%
              pivot_wider(id_cols = ReplicateName, names_from = AnalyteGroup, names_prefix = "TotalAbundance_",
                          values_from = Abundance, values_fn = function(x) sum(x, na.rm=TRUE)),
            by = "ReplicateName")

#Summary (sum) of contaminants
conta_summ_sample_risk <-
  conta_summ_sample %>%
  select(-TotalAbundance) %>%
    # rename(TotalAbundance_Total = TotalAbundance) %>%
  select(Condition, Sample, starts_with("TotalAbundance_")) %>%
  pivot_longer(cols = starts_with("Total"),
               names_to = "AnalyteGroup",
               names_prefix = "TotalAbundance_",
               values_to = "Abundance_median") %>%
  left_join(., ref_conta_tshd_sum,  by = "AnalyteGroup") %>%
  mutate(RiskLevel = case_when(Abundance_median ==0 ~ 0,
                               Abundance_median < Tshd_Area_TICA_perc25 ~ 1,
                               (Tshd_Area_TICA_perc25 <= Abundance_median & Abundance_median < Tshd_Area_TICA_perc50) ~ 2,
                               (Tshd_Area_TICA_perc50 <= Abundance_median & Abundance_median < Tshd_Area_TICA_perc75) ~ 3,
                               (Tshd_Area_TICA_perc75 <= Abundance_median & Abundance_median < Tshd_Area_TICA_perc90) ~ 4,
                               (Tshd_Area_TICA_perc90 <= Abundance_median) ~ 5,
                               TRUE ~ 6),
         Risk = mgsub(RiskLevel, patt=c(0, 1, 2, 3, 4, 5, 6) ,
                      rep = c("0) Not Detected", "1) Very Low", "2) Low", "3) Medium", "4) High", "5) Very High", "6) No threshold in reference"))) %>%
  mutate(Risk = as.factor(Risk),
         RiskLevel = as.factor(RiskLevel),
         AnalyteGroup = factor(AnalyteGroup, levels = rev(analytegroups_area_ordered$AnalyteGroup)), # order from lowest to highest Abundance_median  (shown inversed in plot)
         Sample = Sample) %>%
  select(-starts_with("Tshd_"))

#Dataset level
conta_summ_sampleset <-
  conta_summ_sample %>%
  count(Risk, name = "Count") %>%
  mutate(Fraction = paste0(Count, "/", sum(Count)) ,
         Freq =  round(Count/sum(Count), 2),
         Perc = label_percent()(Freq),
         Tag = paste0(Risk, ": ", Perc, " (", Fraction, ")")) 
conta_summ_sampleset_verbose <- 
  conta_summ_sampleset %>% 
  summarise(Risk  =  paste0(Tag, collapse = "; "), .groups = "drop")
# Verbose summary of the data set
max_risklevel <- max(as.numeric(conta_summ_sample$RiskLevel))
summ_msg_options <- c("Something may be wrong, all Abundances were = 0"  ,
                      "You don't like getting soappy, your samples are super clean!",
                      "You are clean to go!",
                      "Be careful, you have some medium dirty samples",
                      "WARNING: You have some dirty samples!",
                      "WARNING: You have some very dirty samples!!!")
summ_msg <- summ_msg_options[max_risklevel]
summ_color_scale <- scales::viridis_pal(end=0.8, option =  "plasma", direction = 1)(7)
summ_color <- summ_color_scale[max_risklevel]

conta_summ_analytegroup_sample <- 
  conta %>% 
  group_by(Condition, Sample, ReplicateName, AnalyteGroup) %>% 
  summarise( Abundance= sum(Abundance), .groups = "drop") 

```


# Summary risk evaluation (total contamination = sum(Abundance)) {.tabset}

`r colorize_text(summ_msg, summ_color)`

* Evaluation based on the total contaminant abundance
* The results are summarized at different levels below as plots and tables

## Global

The data set contained the following percentages of samples associated to each risk level (also saved in `r filedir_report` --> conta_summ_sampleset)

```{r plot_conta_summ_sampleset, fig.width= 4, fig.height=4}
conta_summ_sampleset %>% 
  arrange(desc(Risk)) %>% 
  mutate(ypos = cumsum(Freq) - 0.5*Freq) %>% 
  ggplot(aes(x = "", y= Freq , fill= Risk)) +
  geom_bar(stat = "identity", color = "white") +
  coord_polar("y", start=0) +
  geom_text(aes(y = ypos, label = Perc), color = "white", size=4) +
  theme_void()  +
  scale_fill_risk_level()
```

## Condition {.tabset}


## Sample {.tabset}

* The table can also be found in `r filedir_report` --> conta_summ_sample.
* RiskLevel = "1) Very Low (OK)", "2) Low (OK)", "3) Medium (Warning)", "4) High (Warning)", "5) Very High (DO NOT PROCEED)", "6) No threshold in reference"

### Plot 

```{r input_conta_summ_sample_risk, echo=FALSE}
# user input for plots
fluidRow(
  column(3,radioButtons(inputId =  "abundance_scale_sample_total",
                        label = "Scale",
                        choices = c("linear", "log10"),
                        selected = "linear",
                        inline = FALSE, 
                        width = "30%")
  ),
  column(5, radioButtons(inputId =  "order_sample_total",
                         label = "Order_x",
                         choices = c("Sample", "Abundance"),
                         selected = "Abundance",
                         inline = FALSE, 
                         width = "30%")
  ),
  column(4, checkboxInput(inputId =  "facet_condition_total",
                        label = "Facet by Condition",
                        value  = TRUE,
                        width = "30%")
  )
)

# filter data
conta_summ_sample2plot <- reactive({
  conta_summ_sample
})
```

```{r plot_conta_summ_sample_risk, echo=FALSE, warning=FALSE}
renderPlotly({
  dot_plot_sample_risk_total <-
        # plot_sample_risk_total(conta_summ_sample) # for troubleshooting only
  plot_sample_risk_total(conta_summ_sample2plot(),
                         order_x  = input$order_sample_total,
                         scale = input$abundance_scale_sample_total)
  if(input$facet_condition_total == TRUE){
    dot_plot_sample_risk_total <-
      dot_plot_sample_risk_total + 
      facet_wrap(~Condition, scales = "free_x")
  }else{
     dot_plot_sample_risk_total <- dot_plot_sample_risk_total
  }
  
  ggplotly(dot_plot_sample_risk_total,
           height = 400, width = 1000) %>%  #when height > 400, the plot overlaps with the next segment of text. add <br><br> below this chunk to introduce a line per additional 50px
  layout_ggplotly_label_margin( x = -0.0, y = -0.02) #fixes label margin problem
  
})
```

### Table

```{r echo=FALSE, warning=FALSE}
conta_summ_sample %>% 
  select(Condition, Sample, ReplicateName, TotalAbundance, RiskLevel) %>% 
  rename_with(~gsub(patt = "TotalAbundance_", rep = "", .x)) %>% 
  datatable(filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))  %>% 
  formatStyle('RiskLevel',
              backgroundColor = styleEqual(c(0:6),c(scales::viridis_pal(end=0.8, option =  "plasma", direction = 1)(7))),
              backgroundSize = '50% 0%',
              backgroundRepeat = 'no-repeat',
              backgroundPosition = 'left')

```

# Contaminant group (median(Abundance)){.tabset}

## Condition{.tabset}

### dotplot

```{r plot_AnalyteGroupCondition, echo=FALSE}
#dotplot
## AnalyteGroup 
dot_plot_conta_summ_condition_risk_analytegroup <-
  conta_summ_sample_risk %>% 
  plot_condition_risk_analyte(order_x = "Condition", order_y = "Abundance", show_zeros = FALSE)

ggplotly(dot_plot_conta_summ_condition_risk_analytegroup,
         height = 600, width = 1000) 
  # layout_ggplotly_label_margin( x = -0.0, y = -0.05) #fixes label margin problem
```

### boxplot

```{r}
conta_summ_analytegroup_sample %>% 
  ggplot(aes(y = AnalyteGroup, x = Abundance)) +
    geom_point(aes(text = paste("Replicate: ", ReplicateName, "\nSample: ", Sample)) , alpha = 0.5, size = 1) +
  geom_boxplot( alpha = 0.4, width = 0.2, size = 0.2, outlier.shape = NA, outlier.size = 0, outlier.alpha = 0, outlier.color = NA, outlier.fill = NA) +
  # scale_y_continuous(n.breaks = 5) +
  xlab("Abundance") +
  ylab("Contaminant") +
  theme_hd +
  ggtitle("Total (sum) abundance of contaminants") 
```

## Sample {.tabset}

### dotplot

```{r plot_AnalyteGroupSample, echo=FALSE}
#dotplot
## AnalyteGroup 
dot_plot_conta_summ_sample_risk_analytegroup <-
  conta_summ_sample_risk %>% 
  plot_sample_risk_analyte(order_x = "Sample", order_y = "Abundance", show_zeros = FALSE)

ggplotly(dot_plot_conta_summ_sample_risk_analytegroup,
         height = 600, width = 1000) 
  # layout_ggplotly_label_margin( x = -0.0, y = -0.05) #fixes label margin problem

```

### boxplot


# Contaminants per sample{.tabset}

* A summary of the Abundance per AnalyteGroup was calculated and is reported in the annexed report (`r filedir_report` --> conta_summ_analytegroup).
* The Abundance of the contaminants are reported in the plots below for all the samples in the data set.
* The Pseudochromatograms represent the Abundance in function of the RentetionTime (Apex of the peak). Those can be useful to evaluate the presence of the usual patterns of polymers, i.e. from small to larger molecules; as well as the reproducibility of the RentetionTime across replicates.

```{r input_AnalyteGroup, echo=FALSE}
MedianMin2Plot_ag = HowDirty::min_no_zero(conta_summ_analytegroup$Abundance_median)

# user input for plots
selectizeInput(inputId = "AnalyteGroup2Plot",
               label = "Select up to 2 contaminant groups (list ordered from highest to lowest median(Abundance))",
               choices = unique(analytegroups_area_ordered$AnalyteGroup),
               multiple = TRUE,
               options = list(maxItems = 2),
               selected = analytegroups_area_ordered$AnalyteGroup[c(1,2)], 
               width = "70%")
fluidRow(
  column(3,
         radioButtons(inputId =  "abundance_scale_ag",
                      label = "Scale",
                      choices = c("linear", "log10"),
                      selected = "linear",
                      inline = FALSE, 
                      width = "30%")
  ),
  column(6,
         sliderInput(inputId = "MedianMin2Plot_ag",
                     label = "Plot contaminants with log10(median) > " ,
                     min = HowDirty::min_no_zero(conta_summ_analytegroup$Abundance_median), #min no zero
                     max = signif(log10(max(conta_summ_analytegroup$Abundance_median)), 3), #max in whole dataset
                     value = HowDirty::min_no_zero(conta_summ_analytegroup$Abundance_median), 
                     width = "70%")
  )
)
# select layers (#ToDo maybe)
# selectInput(inputId = "Layers2Show",
#             "Select layers to show in the plot",
#             choices = c("Points", "Boxplot"),
#             multiple = TRUE,
#             selected = c("Points", "Boxplot"))
# filter data
conta_area2plot <- reactive({
  conta %>% 
    filter(AnalyteGroup %in% input$AnalyteGroup2Plot) %>% 
    filter(Analyte %in% as.character(pull(filter(conta_summ_analyte, Abundance_median > input$MedianMin2Plot_ag), Analyte)))
})
```

## Normalized abundance

```{r plot_AnalyteGroupArea, echo=FALSE, fig.height=10, fig.width=10, warning=FALSE}
renderPlotly({
  ggplotly(plot_abundance(conta_area2plot(), scale = input$abundance_scale_ag),
           height = 600, width = 1000) %>%  #when height > 400, the plot overlaps with the next segment of text. add <br><br> below this chunk to introduce a line per additional 50px 
    layout_ggplotly_label_margin( x = -0.0, y = -0.02) #fixes label margin problem
})

```

<br><br>
<br><br>
<br><br>
<br><br>
<br><br>

## Pseudochromatograms (Abundance vs. RT)

```{r plot_AnalyteGroupPseudoChromato, echo=FALSE, fig.height=10, fig.width=10, warning=FALSE}
renderPlotly({
  ggplotly(plot_pseudochromatogram(conta_area2plot(), scale = input$abundance_scale_ag),
           height = 600, width = 1000) %>%  #when height > 400, the plot overlaps with the next segment of text. add <br><br> below this chunk to introduce a line per additional 50px 
    layout_ggplotly_label_margin( x = -0.0, y = -0.02) #fixes label margin problem
})
```

<br><br>
<br><br>
<br><br>
<br><br>
<br><br>


## Table

* The following table shows the results of possible contaminants detected in each sample.
* An extended version of this table containing the Area and Total-Ion-Count-Area (TICA) can also be found in `r filedir_report` --> conta.
* RiskLevel = "1) Very Low (OK)", "2) Low (OK)", "3) Medium (Warning)", "4) High (Warning)", "5) Very High (DO NOT PROCEED)", "6) No theshold in reference"

```{r table_conta, echo=FALSE, warning=FALSE}
conta %>% 
  select(AnalyteGroup, Analyte, Condition, Sample, ReplicateName, RiskLevel, Abundance) %>% 
  arrange(desc(Abundance)) %>% 
  datatable(filter = 'top', 
            options = list(pageLength = 10, autoWidth = TRUE)) %>% 
  formatStyle('RiskLevel',
              backgroundColor = styleEqual(c(0, 1, 2, 3, 4, 5, 6),c(scales::viridis_pal(end=0.8, option =  "plasma", direction = 1)(7))))
```


# Appendixes

* Plots are exported in folder 4_figures.
* Result tables are exported in folder `r filedir_report`.

```{r echo=FALSE, warning=FALSE}
res_list<- list(conta=conta, 
             conta_summ_sample=conta_summ_sample,
             conta_summ_sampleset=conta_summ_sampleset,
             conta_summ_analytegroup=conta_summ_analytegroup,
             ref_conta_tshd=ref_conta_tshd,
             ref_conta_tshd_sample=ref_conta_tshd_sample)
write.xlsx(res_list,
           file = filedir_report)
writeLines(capture.output(sessionInfo()), filedir_sessioninfo)

```


# References
- Gomez-Zepeda *et al.*. HowDirty. Under preparation. (2023).
- Rardin, M. J. Rapid Assessment of Contaminants and Interferences in Mass Spectrometry Data Using Skyline. J. Am. Soc. Mass Spectrom. 29, 1327â€“1330 (2018).
